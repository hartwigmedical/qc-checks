#!/usr/bin/env bash
# shellcheck disable=SC2155

function main() {
    local runDirs=("$@")
    local totalFailures=0

    echo
    for runDir in "${runDirs[@]}"; do
        info "-----------------------"
        info " Checking Rundir path:  ${runDir}"
        info "-----------------------"

        DirsizeCheck "${runDir}" || ((failures++))
        PipelineCheckLogCheck "${runDir}" || ((failures++))
        CoreDumpCheck "${runDir}" || ((failures++))
        UnhandledJobErrorsCheck "${runDir}" || ((failures++))
        iniEnabled CNV_FREEC "${runDir}" &&
            { FreecPngCheck "${runDir}" || ((failures++)); }
        iniEnabled SOMATIC_VARIANTS "${runDir}" &&
            { SomaticsMergedCheck "${runDir}" || ((failures++)); }
        iniEnabled SOMATIC_VARIANTS "${runDir}" &&
            { SomaticsMeltedCheck "${runDir}" || ((failures++)); }
        iniEnabled INDELREALIGNMENT "${runDir}" &&
            { BamSliceCheck "${runDir}" || ((failures++)); }
        iniEnabled INDELREALIGNMENT "${runDir}" &&
            { PrePostRealignDiffCheck "${runDir}" || ((failures++)); }
        iniEnabled ANNOTATE_VARIANTS "${runDir}" &&
            { VcfSliceCheck "${runDir}" || ((failures++)); }
        WGSMetricsCheck "${runDir}" || ((failures++))
        iniEnabled KINSHIP "${runDir}" &&
            { KinshipCheck "${runDir}" || ((failures++)); }
        ReadMeCheck "${runDir}" || ((failures++))

        echo

        [[ $failures -gt 0 ]] && warn "${failures} FAILURES IN ${runDir}"
        ((totalFailures += failures))
        failures=0
    done
    [[ $totalFailures -gt 0 ]] && error "${totalFailures} TOTAL FAILURES"
    ShowCommands "${runDir}"
}

function iniEnabled() {
    local key=$1 && shift
    local runDir=$1 && shift
    local logsDir=${runDir}/logs
    local iniFiles=$(find "${logsDir}" -maxdepth 1 -type f -name "*.ini")
    if [[ -z "${iniFiles}" ]]; then
        error "No INI file found!"
    else
        local values=$(grep -hE "^${key}\s+" ${iniFiles} | cut -f2 | sort | uniq)
        local valueCount=$(echo "${values}" | wc -l)
        [[ ${valueCount} -ne 1 ]] && error "${key} has multiple values: $(echo ${values})"
        [[ ${values} != "yes" ]] && info "${key} disabled" && return 1
        return 0
    fi
}

function FreecPngCheck() {
    local runDir=$1 && shift
    local copynumberDir=${runDir}/copyNumber
    if [[ -n $(find "${copynumberDir}"/*/freec/ -mindepth 1 -maxdepth 1 -type f -iname "*.png" -size +0 2>/dev/null) ]]; then
        ok
        return 0
    else
        fail "No non-empty Freec copy number PNG present!"
        return 1
    fi
}

function DirsizeCheck() {
    local runDir=$1 && shift
    if [[ ! -d "${runDir}" ]]; then
        error "Rundir does not exist (${runDir})"
    else
        local dirSize=$(du -sh "${runDir}" | cut -f 1)
        maybeOk "${dirSize}"
        return 0
    fi
}

function PipelineCheckLogCheck() {
    local runDir=$1 && shift
    local logsDir=${runDir}/logs
    local checkFile=${logsDir}/PipelineCheck.log
    if [[ ! -s "${checkFile}" ]]; then
        fail "${checkFile} does not exist"
        return 1
    else
        info "Version: $(grep "Pipeline version" "${checkFile}" 2>/dev/null)"
        if tail -1 "${checkFile}" 2>/dev/null | grep -q "pipeline completed successfully"; then
            ok
            return 0
        else
            fail "Pipeline Error!"
            cat "${checkFile}"
            return 1
        fi
    fi
}

function CoreDumpCheck() {
    local runDir=$1 && shift
    local coreDumpFiles=$(find "${runDir}" -type f -name "core.*" 2>/dev/null)
    if [[ -z "${coreDumpFiles}" ]]; then
        ok
        return 0
    else
        # remove newlines via echo
        fail "Found core dump(s): $(echo ${coreDumpFiles})"
        return 1
    fi
}

function UnhandledJobErrorsCheck() {
    local runDir=$1 && shift
    local unhandledErrorLog=${runDir}/logs/unhandled_job_errors
    if [[ -s "${unhandledErrorLog}" ]]; then
        local errorLineCount=$(wc -l "${unhandledErrorLog}" | cut -d" " -f 1)
        fail "Found unhandled errors in ${unhandledErrorLog} (${errorLineCount} lines in file)"
        return 1
    else
        ok
        return 0
    fi
}

function SomaticsMergedCheck() {
    local runDir=$1 && shift
    local somaticsDir=${runDir}/somaticVariants
    if [[ -n $(find "${somaticsDir}" -mindepth 2 -maxdepth 2 -type f -wholename "*_merged_somatics.vcf" -size +0 2>/dev/null) ]]; then
        ok
        return 0
    else
        fail "No non-empty merged somatics VCF found!"
        return 1
    fi
}

function SomaticsMeltedCheck() {
    local runDir=$1 && shift
    local somaticsDir=${runDir}/somaticVariants
    local meltedFile=$(find "${somaticsDir}" -mindepth 2 -maxdepth 2 -type f -wholename "*_melted.vcf" -size +0 2>/dev/null | head -1)
    if [[ -n ${meltedFile} ]]; then
        local meltedCount=$(wc -l "${meltedFile}" | cut -d" " -f 1)
        ok "(${meltedCount} lines in file)"
        return 0
    else
        fail "No non-empty melted somatics VCF found!"
        return 1
    fi
}

function BamSliceCheck() {
    local runDir=$1 && shift
    if [[ -n $(find "${runDir}" -mindepth 3 -maxdepth 3 -type f -wholename "*/mapping/*realigned.sliced*.bam" -size +0 2>/dev/null) ]]; then
        ok
        return 0
    else
        fail "No non-empty BAM slice found!"
        return 1
    fi
}

function PrePostRealignDiffCheck() {
    local runDir=$1 && shift
    if [[ -n $(find "${runDir}" -mindepth 3 -maxdepth 3 -type f -wholename "*/mapping/*prepostrealign.diff" 2>/dev/null) ]]; then
        ok
        return 0
    else
        fail "No PrePostRealignDiff found!"
        return 1
    fi
}

function VcfSliceCheck() {
    local runDir=$1 && shift
    if [[ -n $(find "${runDir}" -maxdepth 1 -type f -iname "*sliced*.vcf" -size +0 2>/dev/null) ]]; then
        ok
        return 0
    else
        fail "No non-empty VCF slice found!"
        return 1
    fi
}

function WGSMetricsCheck() {
    local runDir=$1 && shift
    local qcstatsDir=${runDir}/QCStats
    local wgsmetricsFile="${qcstatsDir}/WGSMetrics_summary.txt"
    if [[ -s ${wgsmetricsFile} ]]; then
        maybeOk "$(cut -f 1,3,4,5,8,13 "${wgsmetricsFile}" | column -t)"
        return 0
    else
        fail "No non-empty WGSMetrics file found!"
        return 1
    fi
}

function KinshipCheck() {
    local runDir=$1 && shift
    local kinshipFile=$(find "${runDir}" -maxdepth 1 -mindepth 1 -type f -iname "*.kinship" -size +0 2>/dev/null)
    if [[ -n ${kinshipFile} ]]; then
        maybeOk "$(cut -f 2,4,6,7,8 "${kinshipFile}" | column -t)"
        return 0
    else
        fail "No non-empty kinship file found!"
        return 1
    fi
}

function ReadMeCheck() {
    local runDir=$1 && shift
    local readmeFile=${runDir}/README
    if [[ -s ${readmeFile} ]]; then
        maybeOk "$(cat "${readmeFile}")"
    fi
    return 0
}

function ShowCommands() {
    local runDir=$1 && shift
    if [[ $(hostname) =~ "hmf_crunch" ]]; then
        echo
        info "Various commands for quick access"
        info "Commands to copy QCStats to NAS webserver location:"
        for runDir in "${runDirs[@]}"; do
            local runName=$(basename "${runDir}")
            local qcstatsDir=${runDir}/QCStats
            echo "rsync -ahP --stats ${qcstatsDir} nas:/volume1/web/qc/pipeline/${runName}_QCStats"
        done
    fi
}

function log() {
    local level=$1 && shift
    local msg=$1 && shift
    echo "[${level}] ${msg}"
}

function error() {
    log "ERROR" "$1"
    exit 1
}

function warn() {
    log "WARN" "$1"
}

function info() {
    log "INFO" "$1"
}

function ok() {
    local note=${1+" $1"}
    info "${FUNCNAME[1]} OK${note}"
}

function maybeOk() {
    local data=$1 && shift
    info "${FUNCNAME[1]}"
    echo "$data"
}

function fail() {
    local cause=$1 && shift
    warn "${FUNCNAME[1]}: ${cause}"
}

if [[ $# -eq 0 ]]; then
    echo "---"
    echo " Descr: Performs some checks on certain output files and prints all to screen"
    echo " Usage: $(basename "$0") /path/to/pipeline/output/dir/"
    echo "        $(basename "$0") /path1 /path2"
    echo "---"
#    exit 1
else
    main "$@"
fi
