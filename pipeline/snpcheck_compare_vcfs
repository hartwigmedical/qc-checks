#!/usr/bin/perl
use strict;
use warnings;
use 5.16.0;
use Data::Dumper;
use Getopt::Long;
use File::Basename;


my $SCRIPT_NAME = `basename $0`; chomp($SCRIPT_NAME);
my $MIN_INFORMATIVE = 24; # min amount of called positions
my $MAX_DISTANCE = 4; # max distance between samples (HOM ref > HOM alt counts as 2)
my %GENOTYPE_CONVERSION = ( './.'=>'-', '0/0'=>'0', '1/0'=>'1', '0/1'=>'1', '1/1'=>'2' );

my $HELP_TEXT = <<EOF;
 ---
 Description:  
   Compares genotypes of two vcfs. Returns OK if SNPcheck criteria are met.
     criterium: minimal informative pos = $MIN_INFORMATIVE
     criterium: maximum samples distance = $MAX_DISTANCE
 Run with:
   $SCRIPT_NAME -vcf \${file1} -vcf \${file2}
 Notes:
   When less or more than 2 vcfs are provided only a call table is printed.
   Criteria are now based on 32SNP panel
 ---
EOF

my $help;
my $verbose;

print $HELP_TEXT and exit(0) if scalar(@ARGV) == 0;
GetOptions (
    #"vcf=s@" => \@vcfs,
    "help|h" => \$help,
    "verbose" => \$verbose,
) or die("Error in command line arguments\n");
print $HELP_TEXT and exit(0) if $help;

## input checks 
my @vcfs = @ARGV;
my $vcfCount = scalar @vcfs;
die "[ERROR] No input vcfs provided?\n" unless $vcfCount;
foreach my $inputFile ( @vcfs ){
    die "[ERROR] File not found ($inputFile)\n" unless -f $inputFile;
}

## -----
## main
## -----
my %store = ();
my @shortNames = ();
my $idx = 1;    
foreach my $vcfFile ( @vcfs ){
    my $vcfName = 'vcf'.sprintf( "%02s", $idx);
    push( @shortNames, $vcfName );
    $idx++;
    say "[INFO] ShortName $vcfName for input file: $vcfFile";
    parseVcf( $vcfFile, $vcfName, \%store );
}

if ( $vcfCount == 2 ){
    compareCalls( \%store, 'vcf01', 'vcf02' );
}
else{
    say "[INFO] More (or less) than 2 input vcfs so will just print table";
    printCallTable( \%store, \@shortNames );
}

## -----
## subroutines
## -----
sub printCallTable{
    my ( $storeObject, $vcfNames ) = @_;
    
    my @regions = sort keys %$storeObject;    
    my @chroms = map( $storeObject->{ $_ }{ 'chr' }, @regions );
    say "[INFO] Chr:   ".join( " ", map( sprintf( "%2s", $_ ), @chroms ) );
    
    foreach my $vcfName ( @$vcfNames ){
        my @calls = map( $storeObject->{ $_ }{ $vcfName }, @regions );
        say "[INFO] $vcfName: ".join( " ", map( sprintf( "%2s", $_ ), @calls ) );
    }
}

sub compareCalls{
    my ( $storeObject, $name1, $name2 ) = @_;
    say "[INFO] Start comparison of $name1 to $name2";
    
    my $skipped = 0;
    my $failed = 0;
    my $equal = 0;
    my $unequal = 0;
    my $distance = 0;
    
    my @print_order = sort keys %$storeObject;    
    my @toprint_chroms = ();
    my @toprint_calls1 = ();
    my @toprint_calls2 = ();
    my @toprint_result = ();
    
    foreach my $loc ( @print_order ){
      
        my $info = $storeObject->{ $loc };
        die "[ERROR] No call found on $loc by name ($name1)\n" unless exists $info->{ $name1 };
        die "[ERROR] No call found on $loc by name ($name2)\n" unless exists $info->{ $name2 };
        
        ## a call is one of [-012]
        my $chr = $info->{ 'chr' };
        my $call1 = $info->{ $name1 };
        my $call2 = $info->{ $name2 };
        
        push( @toprint_chroms, $chr );
        push( @toprint_calls1, $call1 );
        push( @toprint_calls2, $call2 );
        
        ## only autosomal 
        if ( $chr !~ m/^\d+$/ ){
            $skipped++;
            push( @toprint_result, '-' );
        }
        ## failed so uninformative
        elsif ( $call1 eq '-' or $call2 eq '-' ){
            $failed++;
            push( @toprint_result, '-' );
        }
        ## informative AND...
        else{
            ## ...the same
            if ( $call1 eq $call2 ){
                $equal++;
                push( @toprint_result, 'Y' );
            }
            ## ...different
            else{
                $unequal++;
                $distance += abs( $call1 - $call2 );
                push( @toprint_result, 'N' );
            }
        }
        
    }
    my $totalInformative = $equal + $unequal;
    my $equalPerc = sprintf( "%.2f", ($equal*100 / $totalInformative) );
    my $unequalPerc = sprintf( "%.2f", ($unequal*100 / $totalInformative) );
    
    say "[INFO] Total skipped = $skipped";
    say "[INFO] Total failed = $failed";
    say "[INFO] Total informative = $totalInformative (min required: $MIN_INFORMATIVE)";
    say "[INFO] Total informative and equal = $equal ($equalPerc%)";
    say "[INFO] Total informative but unequal = $unequal ($unequalPerc%)";
    say "[INFO] Total distance between samples = $distance (max allowd: $MAX_DISTANCE)";
    say "[INFO] Chrom: ".join( " ", map( sprintf( "%2s", $_ ), @toprint_chroms ) );
    say "[INFO] file1: ".join( " ", map( sprintf( "%2s", $_ ), @toprint_calls1 ) );
    say "[INFO] file2: ".join( " ", map( sprintf( "%2s", $_ ), @toprint_calls2 ) );
    say "[INFO] Match: ".join( " ", map( sprintf( "%2s", $_ ), @toprint_result ) );
    
    ## determine final OK or FAIL
    if ( $equal+$unequal < $MIN_INFORMATIVE ){
        say "[WARN] FINAL RESULT = FAIL (reason: not enough informative pos: $totalInformative < $MIN_INFORMATIVE)" and exit(1);
    }
    elsif ( $distance > $MAX_DISTANCE ){
        say "[WARN] FINAL RESULT = FAIL (reason: distance between samples too big: $distance > $MAX_DISTANCE)" and exit(1);
    }
    else{
        say "[INFO] FINAL RESULT = OK" and exit(0);
    }
}

sub parseVcf{
    
    my ( $file, $name, $storeObject ) = @_;
    open IN, "<", $file or die "[ERROR] Unable to open file ($file): $!\n";
    
    ## read genotype calls and store them for later comparison
    while ( <IN> ){
        chomp;
        next if $_ =~ /^#/;
        my ( $chr, $pos, $id, $ref, $altString, $qual, $filter, $infoString, $formatString, $sampleString ) = split( "\t", $_ );
        
        my @sampleInfoKeys = split( ':', $formatString );
        my @sampleInfoVals = split( ':', $sampleString );
        my @altVariants = split( ':', $altString );
        my @allAlleles = ( $ref, @altVariants );
        
        die "[ERROR] format ($formatString) and sample ($sampleString) columns diff field count...?" unless scalar @sampleInfoKeys == scalar @sampleInfoVals;
        
        my %sampleMetrics = ();
        foreach my $key ( @sampleInfoKeys ){
            my $val = shift @sampleInfoVals;
            $sampleMetrics{ $key } = $val;
        }
        
        my $genotypeCall = $sampleMetrics{ 'GT' };
        my @genotypes = split( '/', $genotypeCall );
        
        die "[ERROR] wrong number of genotyped alleles (should be 2)" unless scalar @genotypes == 2;
        
        my $genotype1 = $genotypes[0];
        my $genotype2 = $genotypes[1];
        my $numericGenotype = 'NA';
        my @calledAlleles = ("-", "-");
        
        die "[ERROR] Weird genotype ($genotypeCall)" if not exists $GENOTYPE_CONVERSION{ $genotypeCall };
        
        $numericGenotype = $GENOTYPE_CONVERSION{ $genotypeCall };
        @calledAlleles = map( $allAlleles[ $_ ], @genotypes ) if $genotype1 =~ /^\d+/ ;
        
        if ( $verbose ){
            my $alleleString = join( '/', @calledAlleles );
            say "Found $alleleString on $chr:$pos (REF=$ref, ALT=$altString, GT=$genotypeCall)";
        }
        
        my $locationString = $chr.':'.$pos;
        $storeObject->{ $locationString }{ 'chr' } = $chr;
        $storeObject->{ $locationString }{ $name } = $numericGenotype;
    }
    close IN;
    
}

